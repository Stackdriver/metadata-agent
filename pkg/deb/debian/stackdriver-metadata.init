#!/bin/bash
#
# stackdriver-metadata - start and stop the Stackdriver metadata agent
# http://www.stackdriver.com
#
# Copyright (C) 2017 Google
#

### BEGIN INIT INFO
# Provides: stackdriver-metadata
# Required-Start: $local_fs $remote_fs
# Required-Stop: $local_fs $remote_fs
# Should-Start: $network $syslog $named $time
# Should-Stop: $network $syslog $named
# Short-Description: start and stop Stackdriver Metadata Agent
# Description: The Stackdriver Metadata Agent is used with the Stackdriver metadata SaaS service.
# Default-Start: 2 3 4 5
# Default-Stop: 0 1 6
### END INIT INFO

. /lib/lsb/init-functions

export PATH=/sbin:/bin:/usr/sbin:/usr/bin

DISABLE=0

DESC="Stackdriver metadata collection agent"
NAME=stackdriver-metadata
DAEMON=/opt/stackdriver/metadata/sbin/metadatad

PIDFILE=/var/run/stackdriver-metadata.pid

MAXWAIT=30

# Gracefully exit if the package has been removed.
test -x $DAEMON || exit 0

if [ -r /etc/default/${NAME} ]; then
    . /etc/default/${NAME}
fi

if test "$ENABLE_COREFILES" == 1; then
    ulimit -c unlimited
fi

get_instance_id () {
    local iid

    # allow override of instance id in sysconfig file
    if [ -n "$INSTANCE_ID" ]; then
        iid=$INSTANCE_ID
    elif [ -r /opt/stackdriver/hostid ]; then
        iid=$(cat /opt/stackdriver/hostid)
    # RS: Check Rackspace first because we can fail quickly.
    elif [[ -x /usr/bin/xenstore-read && $(/usr/bin/xenstore-read vm-data/provider_data/provider) = "Rackspace" ]]; then
        iid=$(/usr/bin/xenstore-read name |sed -e 's/^instance-//')
    elif [ -z "$SKIP_METADATA_CHECKS" ]; then
        # AWS: If we're on EC2, this ought to return the instance id.
        iid=$(curl --silent -f http://169.254.169.254/latest/meta-data/instance-id 2>/dev/null)
        if [ -z "$iid" ]; then
            # that failed.  let's try to see if it looks like we're on GCE
            iid=$(curl --silent -f -H 'Metadata-Flavor: Google' http://169.254.169.254/computeMetadata/v1/instance/id 2>/dev/null)
        fi
    elif [ -r /sys/hypervisor/uuid -a $(cat /sys/hypervisor/version/extra |grep -c amazon) -eq 0 ]; then
        iid=$(cat /sys/hypervisor/uuid)
    else
        echo 'Unable to discover an id for this machine!' >&2
    fi

    echo $iid
}

gen_hostid() {
    echo "Generating a host id"
    uuidgen > /opt/stackdriver/hostid
    return 0
}

# return:
#   0 if the daemon has been started
#   1 if the daemon was already running
#   2 if the daemon could not be started
#   3 if the daemon was not supposed to be started
d_start() {
    if test "$DISABLE" != 0; then
        # we get here during restart
        log_progress_msg "disabled by /etc/default/$NAME"
        return 3
    fi

    # allow setting a proxy
    if [ -n "$PROXY_URL" ]; then
        export https_proxy=$PROXY_URL
    fi

    start-stop-daemon --start --quiet --oknodo --pidfile "$PIDFILE" \
        --exec $DAEMON \
        || return 2
    return 0
}

still_running_warning="
WARNING: $NAME might still be running.
In large setups it might take some time to write all pending data to
the disk. You can adjust the waiting time in /etc/default/$NAME."

# return:
#   0 if the daemon has been stopped
#   1 if the daemon was already stopped
#   2 if daemon could not be stopped
d_stop() {
    PID=$( cat "$PIDFILE" 2> /dev/null ) || true

    start-stop-daemon --stop --quiet --oknodo --pidfile "$PIDFILE"
    rc="$?"

    if test "$rc" -eq 2; then
        return 2
    fi

    sleep 1
    if test -n "$PID" && kill -0 $PID 2> /dev/null; then
        i=0
        while kill -0 $PID 2> /dev/null; do
            i=$(( $i + 2 ))
            echo -n " ."

            if test $i -gt $MAXWAIT; then
                log_progress_msg "$still_running_warning"
                return 2
            fi

            sleep 2
        done
        return "$rc"
    fi
    return "$rc"
}

case "$1" in
    start)
        log_daemon_msg "Starting $DESC" "$NAME"
        d_start
        case "$?" in
            0|1) log_end_msg 0 ;;
            2) log_end_msg 1 ;;
            3) log_end_msg 255; true ;;
            *) log_end_msg 1 ;;
        esac
        ;;
    stop)
        log_daemon_msg "Stopping $DESC" "$NAME"
        d_stop
        case "$?" in
            0|1) log_end_msg 0 ;;
            2) log_end_msg 1 ;;
        esac
        ;;
    status)
        status_of_proc -p "$PIDFILE" "$DAEMON" "$NAME" && exit 0 || exit $?
        ;;
    restart|force-reload)
        log_daemon_msg "Restarting $DESC" "$NAME"
        d_stop
        rc="$?"
        case "$rc" in
            0|1)
                sleep 1
                d_start
                rc2="$?"
                case "$rc2" in
                    0|1) log_end_msg 0 ;;
                    2) log_end_msg 1 ;;
                    3) log_end_msg 255; true ;;
                    *) log_end_msg 1 ;;
                esac
                ;;
            *)
                log_end_msg 1
                ;;
        esac
        ;;
    genhostid)
        gen_hostid
        ;;
    *)
        echo "Usage: $0 {start|stop|restart|status|force-reload}" >&2
        exit 3
        ;;
esac

# vim: syntax=sh noexpandtab sw=4 ts=4 :
